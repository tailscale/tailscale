// Copyright (c) Tailscale Inc & AUTHORS
// SPDX-License-Identifier: BSD-3-Clause

// Code generated by tailscale/cmd/viewer; DO NOT EDIT.

package netmap

import (
	"encoding/json"
	"errors"
	"time"

	"tailscale.com/tailcfg"
	"tailscale.com/tka"
	"tailscale.com/types/key"
	"tailscale.com/types/views"
	"tailscale.com/util/set"
	"tailscale.com/wgengine/filter/filtertype"
)

//go:generate go run tailscale.com/cmd/cloner  -clonefunc=false -type=NetworkMap

// View returns a read-only view of NetworkMap.
func (p *NetworkMap) View() NetworkMapView {
	return NetworkMapView{ж: p}
}

// NetworkMapView provides a read-only view over NetworkMap.
//
// Its methods should only be called if `Valid()` returns true.
type NetworkMapView struct {
	// ж is the underlying mutable value, named with a hard-to-type
	// character that looks pointy like a pointer.
	// It is named distinctively to make you think of how dangerous it is to escape
	// to callers. You must not let callers be able to mutate it.
	ж *NetworkMap
}

// Valid reports whether v's underlying value is non-nil.
func (v NetworkMapView) Valid() bool { return v.ж != nil }

// AsStruct returns a clone of the underlying value which aliases no memory with
// the original.
func (v NetworkMapView) AsStruct() *NetworkMap {
	if v.ж == nil {
		return nil
	}
	return v.ж.Clone()
}

func (v NetworkMapView) MarshalJSON() ([]byte, error) { return json.Marshal(v.ж) }

func (v *NetworkMapView) UnmarshalJSON(b []byte) error {
	if v.ж != nil {
		return errors.New("already initialized")
	}
	if len(b) == 0 {
		return nil
	}
	var x NetworkMap
	if err := json.Unmarshal(b, &x); err != nil {
		return err
	}
	v.ж = &x
	return nil
}

func (v NetworkMapView) SelfNode() tailcfg.NodeView { return v.ж.SelfNode }

func (v NetworkMapView) AllCaps() views.Map[tailcfg.NodeCapability, struct{}] {
	return views.MapOf(v.ж.AllCaps)
}
func (v NetworkMapView) NodeKey() key.NodePublic              { return v.ж.NodeKey }
func (v NetworkMapView) PrivateKey() key.NodePrivate          { return v.ж.PrivateKey }
func (v NetworkMapView) Expiry() time.Time                    { return v.ж.Expiry }
func (v NetworkMapView) Name() string                         { return v.ж.Name }
func (v NetworkMapView) MachineKey() key.MachinePublic        { return v.ж.MachineKey }
func (v NetworkMapView) Peers() views.Slice[tailcfg.NodeView] { return views.SliceOf(v.ж.Peers) }
func (v NetworkMapView) DNS() tailcfg.DNSConfigView           { return v.ж.DNS.View() }
func (v NetworkMapView) PacketFilter() views.ValueSliceView[filtertype.Match, *filtertype.Match, filtertype.MatchView] {
	return views.SliceOfValueViews[filtertype.Match, *filtertype.Match](v.ж.PacketFilter)
}
func (v NetworkMapView) PacketFilterRules() views.Slice[tailcfg.FilterRule] {
	return v.ж.PacketFilterRules
}
func (v NetworkMapView) SSHPolicy() tailcfg.SSHPolicyView   { return v.ж.SSHPolicy.View() }
func (v NetworkMapView) CollectServices() bool              { return v.ж.CollectServices }
func (v NetworkMapView) DERPMap() tailcfg.DERPMapView       { return v.ж.DERPMap.View() }
func (v NetworkMapView) ControlHealth() views.Slice[string] { return views.SliceOf(v.ж.ControlHealth) }
func (v NetworkMapView) TKAEnabled() bool                   { return v.ж.TKAEnabled }
func (v NetworkMapView) TKAHead() tka.AUMHash               { return v.ж.TKAHead }
func (v NetworkMapView) Domain() string                     { return v.ж.Domain }
func (v NetworkMapView) DomainAuditLogID() string           { return v.ж.DomainAuditLogID }

func (v NetworkMapView) UserProfiles() views.Map[tailcfg.UserID, tailcfg.UserProfileView] {
	return views.MapOf(v.ж.UserProfiles)
}
func (v NetworkMapView) String() string { return v.ж.String() }

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _NetworkMapViewNeedsRegeneration = NetworkMap(struct {
	SelfNode          tailcfg.NodeView
	AllCaps           set.Set[tailcfg.NodeCapability]
	NodeKey           key.NodePublic
	PrivateKey        key.NodePrivate
	Expiry            time.Time
	Name              string
	MachineKey        key.MachinePublic
	Peers             []tailcfg.NodeView
	DNS               tailcfg.DNSConfig
	PacketFilter      []filtertype.Match
	PacketFilterRules views.Slice[tailcfg.FilterRule]
	SSHPolicy         *tailcfg.SSHPolicy
	CollectServices   bool
	DERPMap           *tailcfg.DERPMap
	ControlHealth     []string
	TKAEnabled        bool
	TKAHead           tka.AUMHash
	Domain            string
	DomainAuditLogID  string
	UserProfiles      map[tailcfg.UserID]tailcfg.UserProfileView
}{})
